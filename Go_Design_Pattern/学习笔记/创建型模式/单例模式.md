# 单例模式

单例模式是一种确保一个类只有一个实例，并提供一个全局访问点的设计模式。

在Go语言中，单例模式的实现需要考虑到并发安全，因为在多协程环境下，多个协程可能会同时尝试访问或创建单例实例。

下面是对示例中提供的代码文件的详细解释：

1. **single.go - 单例实现**

   ```go
   package main
   
   import (
       "fmt"
       "sync"
   )
   
   var lock = &sync.Mutex{}
   type single struct {}
   
   var singleInstance *single
   
   func getInstance() *single {
       if singleInstance == nil {
           lock.Lock()
           defer lock.Unlock()
           if singleInstance == nil {
               fmt.Println("Creating single instance now.")
               singleInstance = &single{}
           } else {
               fmt.Println("Single instance already created.")
           }
       } else {
           fmt.Println("Single instance already created.")
       }
       return singleInstance
   }
   ```

   这个文件包含了单例模式的核心实现。`single`结构体是一个空结构体，用于表示单例对象。

   `singleInstance`变量用于存储单例实例，初始值为`nil`。

   `getInstance`函数用于获取单例实例。

   如果`singleInstance`为`nil`，它会加锁以确保在创建单例实例时的线程安全。

   即使多个协程同时调用`getInstance`，加锁机制会保证只有一个协程能够创建单例实例，其他协程会等待直到锁被释放。 在创建单例实例后，`singleInstance`将不再为`nil`，之后的调用将直接返回已创建的单例实例。

2. **main.go - 客户端代码**

   ```
   package main
   
   import (
       "fmt"
   )
   
   func main() {
       for i := 0; i < 30; i++ {
           go getInstance()
       }
       fmt.Scanln()
   }
   ```

   `main.go`文件是客户端代码，它启动了30个协程，每个协程都调用`getInstance`函数来获取单例实例。

   由于单例模式的实现是线程安全的，所以即使在多协程环境下，也只会创建一个`single`实例。

3. **output.txt - 执行结果**

   ```
   Creating single instance now.
   Single instance already created.
   Single instance already created.
   ...
   ```

   这是程序运行后的输出结果。可以看到，尽管有30个协程尝试获取单例实例，但只有第一个协程成功创建了实例，其他协程都检测到实例已经存在。

此外，示例还提供了使用`sync.Once`的单例实现方式，这是一种更简洁的实现单例模式的方法。`sync.Once`确保其关联的函数只执行一次，即使在多个协程环境下也是如此。这种方式避免了手动加锁和解锁的步骤，使得代码更加简洁和易于理解。
